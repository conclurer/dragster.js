import {whichMouseButton, getEventNames} from './helpers/mouse-event-functions';
import {Subscription} from 'rxjs/Subscription';
import {Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/observable/merge';
import 'rxjs/add/operator/takeUntil';
import {Subject} from 'rxjs/Subject';
import {
    IDragsterEvent,
    IDragonItemCoordinates,
    dropTargetLocator,
    shadowElementProvider,
    IDragonDropZone
} from './interfaces/dragster-results';
import {
    getElementBehindPoint,
    getImmediateChild,
    getElementForPosition,
    getNextSibling,
    isInput
} from './helpers/node-functions';
import {Dragster} from './dragster';

/**
 * DragonElement
 * Dragster's dragon'drop handler for one HTMLElement
 */
export class DragonElement {
    // Instance variables
    // Parent Dragster Instance
    public dragster: Dragster | null = null;

    // HTML Element to watch
    protected item: HTMLElement;
    protected itemOriginalCoordinates: IDragonItemCoordinates;

    // Item dragged instead of original
    protected flyingItem: HTMLElement | null = null;

    // Item displayed inside a potential drop zone
    protected shadowItem: HTMLElement | null = null;

    // If true, the drag operation has been cancelled by the user
    protected cancelled: boolean = false;

    // If true, the user is currently dragging this.item
    protected dragging: boolean = false;

    // Item Move Stream
    protected itemMoveStream: Subscription;
    protected mouseCoordinatesOnStart: IDragonItemCoordinates;
    protected lastDropTarget: HTMLElement | null = null;
    protected currentSibling: HTMLElement | null;

    // Event Emitter
    protected emitter: Subject<IDragsterEvent> = new Subject<IDragsterEvent>();

    // Configuration
    // Drop Target Locator
    public dropTargetLocator: dropTargetLocator = DragonElement.defaultDropTargetLocator;
    public shadowElementProvider: shadowElementProvider = DragonElement.defaultShadowElementProvider;
    public ignoreInputTextSelection: boolean;
    public removeOnSpill: boolean;
    public revertOnSpill: boolean;
    public originalContainer: HTMLElement;
    public originalSibling: HTMLElement;
    public direction: string;

    public constructor(item: HTMLElement) {
        this.item = item;
    }

    /**
     * Marks the this.item as grabbed. If the user starts to move their mouse the element will be dragged.
     * @param e
     */
    public grab(e: MouseEvent): void {
        // Check if the event has to be ignored ~> not generated by touch or left mouse button
        if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) return;

        // Save mouse coordinates of start
        this.mouseCoordinatesOnStart = {x: e.clientX, y: e.clientY};

        // Setup stream
        this.setupStream();
    }

    /**
     * Returns true if this.item is currently being dragged.
     * @returns {boolean}
     */
    public isDragging(): boolean {
        return this.dragging;
    }

    /**
     * Returns true if dragging this.item has been cancelled.
     * @returns {boolean}
     */
    public isCancelled(): boolean {
        return this.cancelled;
    }

    /**
     * Returns a stream of all events triggered by this.
     * @returns {Observable<IDragsterEvent>}
     */
    public events(): Observable<IDragsterEvent> {
        return this.emitter.asObservable();
    }

    /**
     * Sets up event streams to oversee the user's interactions and react to them.
     */
    protected setupStream(): void {
        let moveEvents: Observable<Event>[] = getEventNames('mousemove').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        let upEvents: Observable<Event>[] = getEventNames('mouseup').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        // latest coordinates of user
        let clientX: number;
        let clientY: number;

        // Subscribe to user's mouse move events
        this.itemMoveStream = Observable.merge(...moveEvents)
        // Cancel when the user stops to
            .takeUntil(Observable.merge(...upEvents))
            .subscribe(
                // Executed whenever the user moves this.item
                (itemMovedEvent: MouseEvent) => {
                    // Cancel if cancelled
                    if (this.isCancelled()) return;

                    // Save mouse coordinates
                    clientX = itemMovedEvent.clientX;
                    clientY = itemMovedEvent.clientY;

                    // Cancel dragging if wrong mouse button is pressed
                    // Only possibility to detect mouse up in Inputfields
                    if (whichMouseButton(itemMovedEvent) === 0) {
                        this.release(clientX, clientY);
                        return;
                    }

                    // Text selection inside an Input-like HTMLElement
                    // If Dragster is configured to ignoreInputTextSelection, cancel event
                    if (this.ignoreInputTextSelection && !this.isDragging()) {
                        let elementBehindCursor: HTMLElement = <HTMLElement>document.elementFromPoint(clientX, clientY);
                        if (isInput(elementBehindCursor)) {
                            this.release(clientX, clientY);
                            return;
                        }
                    }

                    // Initialize dragging
                    if (!this.isDragging()) this.initializeDrag();

                    // Prevent default behavior
                    itemMovedEvent.preventDefault();

                    // Detect and apply coordinate changes
                    // elementInner: Coordinates of the element including offset of curser to element borders
                    let elementInnerX: number = this.itemOriginalCoordinates.x + (this.mouseCoordinatesOnStart.x - this.itemOriginalCoordinates.x);
                    let elementInnerY: number = this.itemOriginalCoordinates.y + (this.mouseCoordinatesOnStart.y - this.itemOriginalCoordinates.y);

                    // Calculate total x/y position
                    let x: number = clientX - elementInnerX;
                    let y: number = clientY - elementInnerY;

                    // Cancel if there is no flying item
                    if (this.flyingItem == null) return;

                    // Apply style to flyingElement
                    this.flyingItem.style.transform = `translate(${x}px, ${y}px)`;

                    // Detect DropZones below
                    this.detectDropZone(itemMovedEvent.clientX, itemMovedEvent.clientY);
                },
                (error) => console.log(error),

                // Executed when the user stops to drag one element
                () => {
                    this.release(clientX, clientY);
                }
            );
    }

    /**
     * Starts dragging this.item
     */
    protected initializeDrag(): void {
        // Send out start event
        this.emitter.next({
            channel: 'drag',
            data: [this.item]
        });

        // Get offset coordinates for this.item
        let rect: ClientRect = this.item.getBoundingClientRect();
        this.itemOriginalCoordinates = {
            x: rect.left + window.pageXOffset,
            y: rect.top + window.pageYOffset
        };

        // todo apply class (.gu-transit) to dragged element (+ hook)

        // todo: hook for flying mirror
        this.flyingItem = DragonElement.defaultFlyingElementProvider(this.item);

        // Send out cloned event
        this.emitter.next({
            channel: 'cloned',
            /** {@link DragsterClonedEventHandler} */
            data: [this.flyingItem, this.item, 'mirror']
        });

        this.dragging = true;
    }

    /**
     * Detects drop zones below this.flyingItem
     * @param mouseX
     * @param mouseY
     */
    protected detectDropZone(mouseX: number, mouseY: number): void {
        // Cancel if there is no flyingItem
        if (this.flyingItem == null) return;

        let overElement: HTMLElement = getElementBehindPoint(mouseX, mouseY, this.flyingItem);
        let dropZoneContainer: HTMLElement | null = this.dropTargetLocator(overElement, mouseX, mouseY);
        let dropZone: IDragonDropZone | null = null;

        // Find default drop zone configuration (for dropZone)
        if (dropZoneContainer != null) {
            dropZone = this.detectCurrentDropZonePosition(dropZoneContainer, overElement, mouseX, mouseY);
        }

        // Fallback to revertable drop zone if revertOnSpill flag is given
        if (dropZone == null) dropZone = this.detectRevertableDropZone();

        // Determine whether the drop target did change
        let dropTargetDidChange: boolean = (dropZone != null && dropZone.container !== this.lastDropTarget);

        // Re-assign lastDropZone and trigger events
        if (dropTargetDidChange || dropZone == null) {
            // Emit out event
            if (this.lastDropTarget != null) {
                this.emitter.next({
                    channel: 'out',
                    data: [this.item, this.lastDropTarget]
                });
            }

            this.lastDropTarget = dropZone == null ? null : dropZone.container;

            // Emit over event
            if (this.lastDropTarget != null) {
                this.emitter.next({
                    channel: 'over',
                    data: [this.item, this.lastDropTarget]
                });
            }
        }

        // Cancel if dropZone is null
        if (dropZone == null) return;

        // Check conditions for adding shadow to dropZone
        let dropZoneDidChangeAndHasNoSibling: boolean = (dropZone.nextSibling == null && dropTargetDidChange);
        let dropZoneSiblingIsNotShadow: boolean = (dropZone.nextSibling !== this.shadowItem);
        let dropZoneShadowIsNotAlreadyAtPosition: boolean;
        if (this.shadowItem == null) {
            dropZoneShadowIsNotAlreadyAtPosition = (dropZone.nextSibling != null);
        }
        else {
            dropZoneShadowIsNotAlreadyAtPosition = (dropZone.nextSibling !== getNextSibling(this.shadowItem));
        }

        if (dropZoneDidChangeAndHasNoSibling || (dropZoneSiblingIsNotShadow && dropZoneShadowIsNotAlreadyAtPosition)) {
            this.currentSibling = dropZone.nextSibling;

            // Remove existing shadow item if present
            // Do not remove it if it is the original item
            if (this.shadowItem != null && this.shadowItem !== this.item) {
                this.shadowItem.parentNode.removeChild(this.shadowItem);
                this.shadowItem = null;
            }

            // Create new shadowItem
            this.shadowItem = this.shadowElementProvider(this.item, dropZone.container);

            // Insert shadowItem
            dropZone.container.insertBefore(this.shadowItem, dropZone.nextSibling);

            // Emit shadow event
            this.emitter.next({
                channel: 'shadow',
                data: [this.shadowItem, dropZone.container]
            });
        }
    }

    /**
     * Detects the drop zone at the current position. Returns null if no drop zone is assignable.
     * @param detectedDropZone
     * @param elementWithin
     * @param mouseX
     * @param mouseY
     * @returns {IDragonDropZone}
     */
    protected detectCurrentDropZonePosition(detectedDropZone: HTMLElement, elementWithin: HTMLElement, mouseX: number, mouseY: number): IDragonDropZone | null {
        if (detectedDropZone == null) return null;

        // Find child in Drop Zone
        let immediate: HTMLElement | null = getImmediateChild(detectedDropZone, elementWithin);

        if (immediate != null) {
            let reference: HTMLElement | null = getElementForPosition(detectedDropZone, immediate, mouseX, mouseY, this.direction);

            // Return dropZone
            return {container: detectedDropZone, nextSibling: reference};
        }
        else return null;
    }

    /**
     * Returns the revertable drop zoen if revertOnSpill is active.
     * @returns {IDragonDropZone}
     */
    protected detectRevertableDropZone(): IDragonDropZone | null {
        if (!this.revertOnSpill) return null;

        return {container: this.originalContainer, nextSibling: this.originalSibling};
    }

    /**
     * Releases this.item currently being dragged at position mouseX|mouseY
     * @param mouseX
     * @param mouseY
     */
    protected release(mouseX: number, mouseY: number): void {
        // Cancel if not dragging
        if (!this.isDragging()) {
            // Emit cancelBeforeDragging event to inform Dragster
            this.emitter.next({channel: 'cancelBeforeDragging', data: []});
            return;
        }

        // Cancel if there is no flyingElement
        if (this.flyingItem == null) return;

        // Detect drop zone
        let overElement: HTMLElement = getElementBehindPoint(mouseX, mouseY, this.flyingItem);
        let dropZone: HTMLElement | null = this.dropTargetLocator(overElement, mouseX, mouseY);

        // todo: custom condition for copy drops
        // todo: dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))
        if (dropZone != null) {
            this.drop(this.item, dropZone);
        }
        else if (this.removeOnSpill) {
            this.remove();
        }
        else {
            this.cancel();
        }

        // Set instance variables
        // Cancel drag events
        this.dragging = false;
        this.cancelled = true;

        // Unsubscribe stream
        if (!this.itemMoveStream.isUnsubscribed) this.itemMoveStream.unsubscribe();
    }

    /**
     * Performs a drop operation of item into target
     * @param item
     * @param target
     */
    protected drop(item: HTMLElement, target: HTMLElement): void {
        // Cancel if not dragging
        if (!this.isDragging()) return;

        // Emit drop event
        this.emitter.next({
            channel: 'drop',
            data: [item, target, this.currentSibling]
        });

        this.cleanup();
    }

    protected remove(): void {
        // Cancel if not dragging
        if (!this.isDragging()) return;

        // Remove this.item
        let parent: HTMLElement = <HTMLElement>this.item.parentNode;
        parent.removeChild(this.item);

        // Emit remove event
        this.emitter.next({
            channel: 'remove',
            data: [this.item, parent]
        });

        this.cleanup();
    }

    /**
     * Cancels the current drag operation. If configured or revert is set, this.item will be reverted to its original position.
     * @param revert
     */
    public cancel(revert: boolean = false): void {
        // Cancel if not dragging
        if (!this.isDragging()) return;

        // Cancel if Dragster is not defined
        if (this.dragster == null) return;

        let reverts: boolean = false; // todo use revert on spill
        if (revert) reverts = true;

        let isInInitialPosition: boolean = this.dragster.isInInitialPlacement(this.lastDropTarget, this.currentSibling);
        if (!isInInitialPosition && reverts) {
            this.dragster.currentSourceContainer().insertBefore(this.item, this.dragster.currentSourceSibling());
        }

        if (isInInitialPosition || reverts) {
            // Emit cancel event
            this.emitter.next({
                channel: 'cancel',
                data: [this.item, this.lastDropTarget]
            });
        }
        else {
            // Emit drop event
            this.emitter.next({
                channel: 'drop',
                data: [this.item, this.lastDropTarget, this.currentSibling]
            });
        }

        this.cleanup();
    }

    /**
     * Performs a cleanup of this, removing the flying element.
     */
    protected cleanup(): void {
        // Cancel if there is no flyingElement
        if (this.flyingItem == null) return;

        // Remove flyingItem
        this.flyingItem.parentNode.removeChild(this.flyingItem);

        // Emit out event for lastDropTarget
        if (this.lastDropTarget != null) {
            this.emitter.next({
                channel: 'out',
                data: [this.item, this.lastDropTarget]
            });
        }

        // Emit dragend event
        this.emitter.next({
            channel: 'dragend',
            data: [this.item]
        });

        // Complete event stream
        this.emitter.complete();
    }

    /**
     * Dragon's default provider for flyingElement. This will clone the original element and append it to the body. #todo
     * @param originalElement
     * @returns {HTMLElement}
     */
    public static defaultFlyingElementProvider(originalElement: HTMLElement): HTMLElement {
        let rect: ClientRect = originalElement.getBoundingClientRect();

        // copy given element and apply it to given container
        let mirror: HTMLElement = <HTMLElement>originalElement.cloneNode(true);
        mirror.style.width = `${rect.width}px`;
        mirror.style.height = `${rect.height}px`;
        mirror.style.top = `${rect.top}px`;
        mirror.style.left = `${rect.left}px`;
        mirror.classList.add('gu-mirror');
        mirror.classList.remove('gu-transit');
        // todo: use options.mirrorContainer
        document.body.appendChild(mirror);
        document.body.classList.add('gu-unselectable');

        return mirror;
    }

    /**
     * Dragon's default provider for shadowElement. This will return the original source item directly.
     * @param itemInMotion
     * @param shadowContainer
     * @returns {HTMLElement}
     */
    public static defaultShadowElementProvider(itemInMotion: HTMLElement, shadowContainer: HTMLElement): HTMLElement {
        return itemInMotion;
    }

    /**
     * Dragon's default drop target locator. This will return no drop target at all.
     * @param elementFlownOver
     * @param mouseX
     * @param mouseY
     * @returns {null}
     */
    public static defaultDropTargetLocator(elementFlownOver: HTMLElement, mouseX: number, mouseY: number): HTMLElement | null {
        return null;
    }

    // Index Signature for DragonElement
    // tslint:disable-next-line
    [key: string]: any;
}
