import {whichMouseButton, getEventNames} from "./helpers/mouse-event-functions";
import {Subscription} from "rxjs/Subscription";
import {Observable} from "rxjs/Observable";
import "rxjs/add/observable/fromEvent";
import "rxjs/add/observable/merge";
import "rxjs/add/operator/takeUntil";
import {Subject} from "rxjs/Subject";
import {IDragsterEvent, IDragonItemCoordinates, dropTargetLocator} from "./interfaces/dragster-results";
import {getElementBehindPoint} from "./helpers/node-functions";

/**
 * DragonElement
 * Dragster's dragon'drop handler for one HTMLElement
 */
export class DragonElement {
    // Instance variables
    // HTML Element to watch
    protected item: HTMLElement;
    protected itemOriginalCoordinates: IDragonItemCoordinates;

    // Item dragged instead of original
    protected flyingItem: HTMLElement = null;

    // If true, the drag operation has been cancelled by the user
    protected cancelled: boolean = false;

    // If true, the user is currently dragging this.item
    protected dragging: boolean = false;

    // Item Move Stream
    protected itemMoveStream: Subscription;
    protected mouseCoordinatesOnStart: IDragonItemCoordinates;

    // Event Emitter
    protected emitter: Subject<IDragsterEvent> = new Subject<IDragsterEvent>();

    // Configuration
    // Drop Target Locator
    public dropTargetLocator: dropTargetLocator = DragonElement.defaultDropTargetLocator;

    public constructor(item: HTMLElement) {
        this.item = item;
    }

    public grab(e: MouseEvent) {
        // Check if the event has to be ignored ~> not generated by touch or left mouse button
        if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) return;

        // Save mouse coordinates of start
        this.mouseCoordinatesOnStart = {x: e.clientX, y: e.clientY};

        // Setup stream
        this.setupStream();
    }

    public isDragging(): boolean {
        return this.dragging;
    }

    public isCancelled(): boolean {
        return this.cancelled;
    }

    protected setupStream(): void {
        let moveEvents = getEventNames('mousemove').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        let upEvents = getEventNames('mouseup').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        // Subscribe to user's mouse move events
        this.itemMoveStream = Observable.merge(...moveEvents)
        // Cancel when the user stops to
            .takeUntil(Observable.merge(...upEvents))
            .subscribe(
                // Executed whenever the user moves this.item
                (itemMovedEvent: MouseEvent) => {
                    // Cancel if cancelled
                    if (this.isCancelled()) return;

                    if (!this.isDragging()) this.initializeDrag();

                    // todo: filter out "false" drags (mouse button must be 1)

                    // Prevent default behavior
                    itemMovedEvent.preventDefault();

                    // Detect and apply coordinate changes
                    // elementInner: Coordinates of the element including offset of curser to element borders
                    let elementInnerX = this.itemOriginalCoordinates.x + (this.mouseCoordinatesOnStart.x - this.itemOriginalCoordinates.x);
                    let elementInnerY = this.itemOriginalCoordinates.y + (this.mouseCoordinatesOnStart.y - this.itemOriginalCoordinates.y);

                    // Calculate total x/y position
                    let x = itemMovedEvent.clientX - elementInnerX;
                    let y = itemMovedEvent.clientY - elementInnerY;
                    this.flyingItem.style.transform = `translate(${x}px, ${y}px)`;

                    this.detectDropZone(itemMovedEvent.clientX, itemMovedEvent.clientY);
                },
                (error) => console.log(error),

                // Executed when the user stops to drag one element
                () => {
                    // todo: stop dragging + cleanup
                    this.dragging = false;
                    this.cancelled = true;
                }
            );
    }

    protected initializeDrag(): void {
        // Send out start event
        this.emitter.next({
            channel: 'drag',
            data: [this.item]
        });

        // Get offset coordinates for this.item
        let rect = this.item.getBoundingClientRect();
        this.itemOriginalCoordinates = {
            x: rect.left + window.pageXOffset,
            y: rect.top + window.pageYOffset
        };

        // todo apply class (.gu-transit) to dragged element (+ hook)

        // todo: hook for flying mirror
        this.flyingItem = DragonElement.defaultFlyingElement(this.item);

        // Send out cloned event
        this.emitter.next({
            channel: 'cloned',
            /** {@link DragsterClonedEventHandler} */
            data: [this.flyingItem, this.item, 'mirror']
        });

        this.dragging = true;
    }

    protected detectDropZone(mouseX: number, mouseY: number): void {
        let overElement = getElementBehindPoint(mouseX, mouseY, this.flyingItem);
        let dropZone = this.dropTargetLocator(overElement, mouseX, mouseY);

        // Cancel if no dropZone was found
        if (dropZone == null) return;
    }

    public static defaultFlyingElement(originalElement: HTMLElement): HTMLElement {
        let rect = originalElement.getBoundingClientRect();

        // copy given element and apply it to given container
        let mirror = <HTMLElement>originalElement.cloneNode(true);
        mirror.style.width = `${rect.width}px`;
        mirror.style.height = `${rect.height}px`;
        mirror.style.top = `${rect.top}px`;
        mirror.style.left = `${rect.left}px`;
        mirror.classList.add('gu-mirror');
        mirror.classList.remove('gu-transit');
        // todo: use options.mirrorContainer
        document.body.appendChild(mirror);
        document.body.classList.add('gu-unselectable');

        return mirror;
    }

    public static defaultDropTargetLocator(elementFlownOver: HTMLElement, mouseX: number, mouseY: number): HTMLElement {
        return null;
    }
}