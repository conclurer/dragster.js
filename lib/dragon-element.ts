import {whichMouseButton, getEventNames} from "./helpers/mouse-event-functions";
import {Subscription} from "rxjs/Subscription";
import {Observable} from "rxjs/Observable";
import "rxjs/add/observable/fromEvent";
import "rxjs/add/observable/merge";
import "rxjs/add/operator/takeUntil";
import {Subject} from "rxjs/Subject";
import {
    IDragsterEvent,
    IDragonItemCoordinates,
    dropTargetLocator,
    shadowElementProvider
} from "./interfaces/dragster-results";
import {
    getElementBehindPoint,
    getImmediateChild,
    getElementForPosition,
    getNextSibling,
    isInput
} from "./helpers/node-functions";
import {Dragster} from "./dragster";

/**
 * DragonElement
 * Dragster's dragon'drop handler for one HTMLElement
 */
export class DragonElement {
    // Instance variables
    // Parent Dragster Instance
    public dragster: Dragster = null;

    // HTML Element to watch
    protected item: HTMLElement;
    protected itemOriginalCoordinates: IDragonItemCoordinates;

    // Item dragged instead of original
    protected flyingItem: HTMLElement = null;

    // Item displayed inside a potential drop zone
    protected shadowItem: HTMLElement = null;

    // If true, the drag operation has been cancelled by the user
    protected cancelled: boolean = false;

    // If true, the user is currently dragging this.item
    protected dragging: boolean = false;

    // Item Move Stream
    protected itemMoveStream: Subscription;
    protected mouseCoordinatesOnStart: IDragonItemCoordinates;
    protected lastDropTarget: HTMLElement = null;
    protected currentSibling: HTMLElement;

    // Event Emitter
    protected emitter: Subject<IDragsterEvent> = new Subject<IDragsterEvent>();

    // Configuration
    // Drop Target Locator
    public dropTargetLocator: dropTargetLocator = DragonElement.defaultDropTargetLocator;
    public shadowElementProvider: shadowElementProvider = DragonElement.defaultShadowElementProvider;
    public ignoreInputTextSelection: boolean;

    public constructor(item: HTMLElement) {
        this.item = item;
    }

    /**
     * Marks the this.item as grabbed. If the user starts to move their mouse the element will be dragged.
     * @param e
     */
    public grab(e: MouseEvent) {
        // Check if the event has to be ignored ~> not generated by touch or left mouse button
        if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) return;

        // Save mouse coordinates of start
        this.mouseCoordinatesOnStart = {x: e.clientX, y: e.clientY};

        // Setup stream
        this.setupStream();
    }

    /**
     * Returns true if this.item is currently being dragged.
     * @returns {boolean}
     */
    public isDragging(): boolean {
        return this.dragging;
    }

    /**
     * Returns true if dragging this.item has been cancelled.
     * @returns {boolean}
     */
    public isCancelled(): boolean {
        return this.cancelled;
    }

    /**
     * Returns a stream of all events triggered by this.
     * @returns {Observable<IDragsterEvent>}
     */
    public events(): Observable<IDragsterEvent> {
        return this.emitter.asObservable();
    }

    /**
     * Sets up event streams to oversee the user's interactions and react to them.
     */
    protected setupStream(): void {
        let moveEvents = getEventNames('mousemove').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        let upEvents = getEventNames('mouseup').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        // latest coordinates of user
        let clientX: number;
        let clientY: number;

        // Subscribe to user's mouse move events
        this.itemMoveStream = Observable.merge(...moveEvents)
        // Cancel when the user stops to
            .takeUntil(Observable.merge(...upEvents))
            .subscribe(
                // Executed whenever the user moves this.item
                (itemMovedEvent: MouseEvent) => {
                    // Cancel if cancelled
                    if (this.isCancelled()) return;

                    // Save mouse coordinates
                    clientX = itemMovedEvent.clientX;
                    clientY = itemMovedEvent.clientY;

                    // Cancel dragging if wrong mouse button is pressed
                    // Only possibility to detect mouse up in Inputfields
                    if (whichMouseButton(itemMovedEvent) === 0) {
                        this.release(clientX, clientY);
                        return;
                    }

                    // Text selection inside an Input-like HTMLElement
                    // If Dragster is configured to ignoreInputTextSelection, cancel event
                    if (this.ignoreInputTextSelection && !this.isDragging()) {
                        let elementBehindCursor = <HTMLElement>document.elementFromPoint(clientX, clientY);
                        if (isInput(elementBehindCursor)) {
                            this.release(clientX, clientY);
                            return;
                        }
                    }

                    // Initialize dragging
                    if (!this.isDragging()) this.initializeDrag();

                    // Prevent default behavior
                    itemMovedEvent.preventDefault();

                    // Detect and apply coordinate changes
                    // elementInner: Coordinates of the element including offset of curser to element borders
                    let elementInnerX = this.itemOriginalCoordinates.x + (this.mouseCoordinatesOnStart.x - this.itemOriginalCoordinates.x);
                    let elementInnerY = this.itemOriginalCoordinates.y + (this.mouseCoordinatesOnStart.y - this.itemOriginalCoordinates.y);

                    // Calculate total x/y position
                    let x = clientX - elementInnerX;
                    let y = clientY - elementInnerY;
                    this.flyingItem.style.transform = `translate(${x}px, ${y}px)`;

                    this.detectDropZone(itemMovedEvent.clientX, itemMovedEvent.clientY);
                },
                (error) => console.log(error),

                // Executed when the user stops to drag one element
                () => {
                    this.release(clientX, clientY);
                }
            );
    }

    /**
     * Starts dragging this.item
     */
    protected initializeDrag(): void {
        // Send out start event
        this.emitter.next({
            channel: 'drag',
            data: [this.item]
        });

        // Get offset coordinates for this.item
        let rect = this.item.getBoundingClientRect();
        this.itemOriginalCoordinates = {
            x: rect.left + window.pageXOffset,
            y: rect.top + window.pageYOffset
        };

        // todo apply class (.gu-transit) to dragged element (+ hook)

        // todo: hook for flying mirror
        this.flyingItem = DragonElement.defaultFlyingElementProvider(this.item);

        // Send out cloned event
        this.emitter.next({
            channel: 'cloned',
            /** {@link DragsterClonedEventHandler} */
            data: [this.flyingItem, this.item, 'mirror']
        });

        this.dragging = true;
    }

    /**
     * Detects drop zones below this.flyingItem
     * @param mouseX
     * @param mouseY
     */
    protected detectDropZone(mouseX: number, mouseY: number): void {
        let overElement = getElementBehindPoint(mouseX, mouseY, this.flyingItem);
        let dropZone = this.dropTargetLocator(overElement, mouseX, mouseY);

        // Determine whether the drop target did change
        let dropTargetDidChange = (dropZone != null && dropZone !== this.lastDropTarget);

        // Re-assign lastDropZone and trigger events
        if (dropTargetDidChange || dropZone == null) {
            // Emit out event
            if (this.lastDropTarget != null) {
                this.emitter.next({
                    channel: 'out',
                    data: [this.item, this.lastDropTarget]
                });
            }

            this.lastDropTarget = dropZone;

            // Emit over event
            if (this.lastDropTarget != null) {
                this.emitter.next({
                    channel: 'over',
                    data: [this.item, this.lastDropTarget]
                });
            }
        }

        // Cancel if dropZone is null
        if (dropZone == null) return;

        // Find child in Drop Zone
        let immediate = getImmediateChild(dropZone, overElement);
        let reference: HTMLElement;

        // Perform checks on immediate
        if (immediate != null) {
            // todo: pass direction
            reference = getElementForPosition(dropZone, immediate, mouseX, mouseY, 'vertical');
        }
        // todo: pass revert on spill
        else if (false) {
            // todo: revert on spill
        }
        // Cancel if no condition applies
        else return;

        // Check conditions for adding shadow to dropZone
        if ((reference == null && dropTargetDidChange) || reference !== this.shadowItem && reference !== getNextSibling(this.shadowItem)) {
            this.currentSibling = reference;

            // Remove existing shadow item if present
            // Do not remove it if it is the original item
            if (this.shadowItem != null && this.shadowItem !== this.item) {
                this.shadowItem.parentNode.removeChild(this.shadowItem);
                this.shadowItem = null;
            }

            // Create new shadowItem
            this.shadowItem = this.shadowElementProvider(this.item, dropZone);

            // Insert shadowItem
            dropZone.insertBefore(this.shadowItem, reference);

            // Emit shadow event
            this.emitter.next({
                channel: 'shadow',
                data: [this.shadowItem, dropZone]
            });
        }
    }

    /**
     * Releases this.item currently being dragged at position mouseX|mouseY
     * @param mouseX
     * @param mouseY
     */
    protected release(mouseX: number, mouseY: number): void {
        // Cancel if not dragging
        if (!this.isDragging()) {
            // Emit cancelBeforeDragging event to inform Dragster
            this.emitter.next({channel: 'cancelBeforeDragging', data: []});
            return;
        }

        // Detect drop zone
        let overElement = getElementBehindPoint(mouseX, mouseY, this.flyingItem);
        let dropZone = this.dropTargetLocator(overElement, mouseX, mouseY);

        // todo: custom condition for copy drops
        // todo: dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))
        if (dropZone != null) {
            this.drop(this.item, dropZone);
        }
        else if (false) {
            // todo: remove on spill
        }
        else {
            this.cancel();
        }

        // Set instance variables
        // Cancel drag events
        this.dragging = false;
        this.cancelled = true;

        // Unsubscribe stream
        if (!this.itemMoveStream.isUnsubscribed) this.itemMoveStream.unsubscribe();
    }

    /**
     * Performs a drop operation of item into target
     * @param item
     * @param target
     */
    protected drop(item: HTMLElement, target: HTMLElement): void {
        // Cancel if not dragging
        if (!this.isDragging()) return;

        // Emit drop event
        this.emitter.next({
            channel: 'drop',
            data: [item, target, this.currentSibling]
        });

        this.cleanup();
    }

    /**
     * Cancels the current drag operation. If configured or revert is set, this.item will be reverted to its original position.
     * @param revert
     */
    public cancel(revert: boolean = false): void {
        // Cancel if not dragging
        if (!this.isDragging()) return;

        let reverts = false; //todo use revert on spill
        if (revert) reverts = true;

        var isInInitialPosition = this.dragster.isInInitialPlacement(this.lastDropTarget, this.currentSibling);
        if (!isInInitialPosition && reverts) {
            this.dragster.currentSourceContainer().insertBefore(this.item, this.dragster.currentSourceSibling());
        }

        if (isInInitialPosition || reverts) {
            // Emit cancel event
            this.emitter.next({
                channel: 'cancel',
                data: [this.item, this.lastDropTarget]
            });
        }
        else {
            // Emit drop event
            this.emitter.next({
                channel: 'drop',
                data: [this.item, this.lastDropTarget, this.currentSibling]
            });
        }

        this.cleanup();
    }

    /**
     * Performs a cleanup of this, removing the flying element.
     */
    protected cleanup(): void {
        // Remove flyingItem
        this.flyingItem.parentNode.removeChild(this.flyingItem);

        // Emit out event for lastDropTarget
        if (this.lastDropTarget != null) {
            this.emitter.next({
                channel: 'out',
                data: [this.item, this.lastDropTarget]
            });
        }

        // Emit dragend event
        this.emitter.next({
            channel: 'dragend',
            data: [this.item]
        });

        // Complete event stream
        this.emitter.complete();
    }

    /**
     * Dragon's default provider for flyingElement. This will clone the original element and append it to the body. #todo
     * @param originalElement
     * @returns {HTMLElement}
     */
    public static defaultFlyingElementProvider(originalElement: HTMLElement): HTMLElement {
        let rect = originalElement.getBoundingClientRect();

        // copy given element and apply it to given container
        let mirror = <HTMLElement>originalElement.cloneNode(true);
        mirror.style.width = `${rect.width}px`;
        mirror.style.height = `${rect.height}px`;
        mirror.style.top = `${rect.top}px`;
        mirror.style.left = `${rect.left}px`;
        mirror.classList.add('gu-mirror');
        mirror.classList.remove('gu-transit');
        // todo: use options.mirrorContainer
        document.body.appendChild(mirror);
        document.body.classList.add('gu-unselectable');

        return mirror;
    }

    /**
     * Dragon's default provider for shadowElement. This will return the original source item directly.
     * @param itemInMotion
     * @param shadowContainer
     * @returns {HTMLElement}
     */
    public static defaultShadowElementProvider(itemInMotion: HTMLElement, shadowContainer: HTMLElement): HTMLElement {
        return itemInMotion;
    }

    /**
     * Dragon's default drop target locator. This will return no drop target at all.
     * @param elementFlownOver
     * @param mouseX
     * @param mouseY
     * @returns {null}
     */
    public static defaultDropTargetLocator(elementFlownOver: HTMLElement, mouseX: number, mouseY: number): HTMLElement {
        return null;
    }
}