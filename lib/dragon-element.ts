import {whichMouseButton, getEventNames} from "./helpers/mouse-event-functions";
import {Subscription} from "rxjs/Subscription";
import {Observable} from "rxjs/Observable";
import "rxjs/add/observable/fromEvent";
import "rxjs/add/observable/merge";
import "rxjs/add/operator/takeUntil";
import {Subject} from "rxjs/Subject";
import {
    IDragsterEvent,
    IDragonItemCoordinates,
    dropTargetLocator,
    shadowElementProvider
} from "./interfaces/dragster-results";
import {
    getElementBehindPoint,
    getImmediateChild,
    getElementForPosition,
    getNextSibling
} from "./helpers/node-functions";

/**
 * DragonElement
 * Dragster's dragon'drop handler for one HTMLElement
 */
export class DragonElement {
    // Instance variables
    // HTML Element to watch
    protected item: HTMLElement;
    protected itemOriginalCoordinates: IDragonItemCoordinates;

    // Item dragged instead of original
    protected flyingItem: HTMLElement = null;

    // Item displayed inside a potential drop zone
    protected shadowItem: HTMLElement = null;

    // If true, the drag operation has been cancelled by the user
    protected cancelled: boolean = false;

    // If true, the user is currently dragging this.item
    protected dragging: boolean = false;

    // Item Move Stream
    protected itemMoveStream: Subscription;
    protected mouseCoordinatesOnStart: IDragonItemCoordinates;
    protected lastDropTarget: HTMLElement;
    protected currentSibling: HTMLElement;

    // Event Emitter
    protected emitter: Subject<IDragsterEvent> = new Subject<IDragsterEvent>();

    // Configuration
    // Drop Target Locator
    public dropTargetLocator: dropTargetLocator = DragonElement.defaultDropTargetLocator;
    public shadowElementProvider: shadowElementProvider = DragonElement.defaultShadowElementProvider;

    public constructor(item: HTMLElement) {
        this.item = item;
    }

    public grab(e: MouseEvent) {
        // Check if the event has to be ignored ~> not generated by touch or left mouse button
        if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) return;

        // Save mouse coordinates of start
        this.mouseCoordinatesOnStart = {x: e.clientX, y: e.clientY};

        // Setup stream
        this.setupStream();
    }

    public isDragging(): boolean {
        return this.dragging;
    }

    public isCancelled(): boolean {
        return this.cancelled;
    }

    protected setupStream(): void {
        let moveEvents = getEventNames('mousemove').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        let upEvents = getEventNames('mouseup').map((eventName: string) => {
            return Observable.fromEvent(document.documentElement, eventName);
        });

        // Subscribe to user's mouse move events
        this.itemMoveStream = Observable.merge(...moveEvents)
        // Cancel when the user stops to
            .takeUntil(Observable.merge(...upEvents))
            .subscribe(
                // Executed whenever the user moves this.item
                (itemMovedEvent: MouseEvent) => {
                    // Cancel if cancelled
                    if (this.isCancelled()) return;

                    if (!this.isDragging()) this.initializeDrag();

                    // todo: filter out "false" drags (mouse button must be 1)

                    // Prevent default behavior
                    itemMovedEvent.preventDefault();

                    // Detect and apply coordinate changes
                    // elementInner: Coordinates of the element including offset of curser to element borders
                    let elementInnerX = this.itemOriginalCoordinates.x + (this.mouseCoordinatesOnStart.x - this.itemOriginalCoordinates.x);
                    let elementInnerY = this.itemOriginalCoordinates.y + (this.mouseCoordinatesOnStart.y - this.itemOriginalCoordinates.y);

                    // Calculate total x/y position
                    let x = itemMovedEvent.clientX - elementInnerX;
                    let y = itemMovedEvent.clientY - elementInnerY;
                    this.flyingItem.style.transform = `translate(${x}px, ${y}px)`;

                    this.detectDropZone(itemMovedEvent.clientX, itemMovedEvent.clientY);
                },
                (error) => console.log(error),

                // Executed when the user stops to drag one element
                () => {
                    // todo: stop dragging + cleanup
                    this.dragging = false;
                    this.cancelled = true;
                }
            );
    }

    protected initializeDrag(): void {
        // Send out start event
        this.emitter.next({
            channel: 'drag',
            data: [this.item]
        });

        // Get offset coordinates for this.item
        let rect = this.item.getBoundingClientRect();
        this.itemOriginalCoordinates = {
            x: rect.left + window.pageXOffset,
            y: rect.top + window.pageYOffset
        };

        // todo apply class (.gu-transit) to dragged element (+ hook)

        // todo: hook for flying mirror
        this.flyingItem = DragonElement.defaultFlyingElement(this.item);

        // Send out cloned event
        this.emitter.next({
            channel: 'cloned',
            /** {@link DragsterClonedEventHandler} */
            data: [this.flyingItem, this.item, 'mirror']
        });

        this.dragging = true;
    }

    protected detectDropZone(mouseX: number, mouseY: number): void {
        let overElement = getElementBehindPoint(mouseX, mouseY, this.flyingItem);
        let dropZone = this.dropTargetLocator(overElement, mouseX, mouseY);

        // Determine whether the drop target did change
        let dropTargetDidChange = (dropZone != null && dropZone !== this.lastDropTarget);

        // Re-assign lastDropZone and trigger events
        if (dropTargetDidChange || dropZone == null) {
            // Emit out event
            if (this.lastDropTarget != null) {
                this.emitter.next({
                    channel: 'out',
                    data: [this.item, this.lastDropTarget]
                });
            }

            this.lastDropTarget = dropZone;

            // Emit over event
            if (this.lastDropTarget != null) {
                this.emitter.next({
                    channel: 'over',
                    data: [this.item, this.lastDropTarget]
                });
            }
        }

        // Cancel if dropZone is null
        if (dropZone == null) return;

        // Find child in Drop Zone
        let immediate = getImmediateChild(dropZone, overElement);
        let reference: HTMLElement;

        // Perform checks on immediate
        if (immediate != null) {
            // todo: pass direction
            reference = getElementForPosition(dropZone, immediate, mouseX, mouseY, 'vertical');
        }
        // todo: pass revert on spill
        else if (false) {
            // todo: revert on spill
        }
        // Cancel if no condition applies
        else return;

        // Check conditions for adding shadow to dropZone
        if ((reference == null && dropTargetDidChange) || reference !== this.shadowItem && reference !== getNextSibling(this.shadowItem)) {
            this.currentSibling = reference;

            // Remove existing shadow item if present
            // Do not remove it if it is the original item
            if (this.shadowItem != null && this.shadowItem !== this.item) {
                this.shadowItem.parentNode.removeChild(this.shadowItem);
                this.shadowItem = null;
            }

            // Create new shadowItem
            this.shadowItem = this.shadowElementProvider(this.item, dropZone);

            // Insert shadowItem
            dropZone.insertBefore(this.shadowItem, reference);

            // Emit shadow event
            this.emitter.next({
                channel: 'shadow',
                data: [this.shadowItem, dropZone]
            });
        }
    }

    public static defaultFlyingElement(originalElement: HTMLElement): HTMLElement {
        let rect = originalElement.getBoundingClientRect();

        // copy given element and apply it to given container
        let mirror = <HTMLElement>originalElement.cloneNode(true);
        mirror.style.width = `${rect.width}px`;
        mirror.style.height = `${rect.height}px`;
        mirror.style.top = `${rect.top}px`;
        mirror.style.left = `${rect.left}px`;
        mirror.classList.add('gu-mirror');
        mirror.classList.remove('gu-transit');
        // todo: use options.mirrorContainer
        document.body.appendChild(mirror);
        document.body.classList.add('gu-unselectable');

        return mirror;
    }

    public static defaultShadowElementProvider(itemInMotion: HTMLElement, shadowContainer: HTMLElement): HTMLElement {
        return itemInMotion;
    }

    public static defaultDropTargetLocator(elementFlownOver: HTMLElement, mouseX: number, mouseY: number): HTMLElement {
        return null;
    }
}